<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
<span id='domain-common-CharSprite'>/**
</span> * CharSprite class handles the character sprite.
 *
 * @class
 * @extends domain.common.Sprite
 */
domain.common.CharSprite = subclass(domain.common.Sprite, function (pt) {
    &#39;use strict&#39;;

    var defaultSpeechTimeout = 5000;

<span id='domain-common-CharSprite-property-x'>    /** sprite&#39;s x coordinate value */
</span>    pt.x = 0;

<span id='domain-common-CharSprite-property-y'>    /** sprite&#39;s y coordinate value */
</span>    pt.y = 0;

<span id='domain-common-CharSprite-property-w'>    /** sprite&#39;s width */
</span>    pt.w = 0;

<span id='domain-common-CharSprite-property-h'>    /** sprite&#39;s width */
</span>    pt.h = 0;

<span id='domain-common-CharSprite-property-upImage'>    /** sprite&#39;s image when going up */
</span>    pt.upImage = &#39;&#39;;

<span id='domain-common-CharSprite-property-downImage'>    /** sprite&#39;s image when going down */
</span>    pt.downImage = &#39;&#39;;

<span id='domain-common-CharSprite-property-leftImage'>    /** sprite&#39;s image when going left */
</span>    pt.leftImage = &#39;&#39;;

<span id='domain-common-CharSprite-property-rightImage'>    /** sprite&#39;s image when going right */
</span>    pt.rightImage = &#39;&#39;;


<span id='domain-common-CharSprite-property-cssClass'>    /** the css class for &lt;img /&gt; of the sprite */
</span>    pt.cssClass = &#39;sprite&#39;;


<span id='domain-common-CharSprite-method-constructor'>    /**
</span>     * @constructor
     * @param {datadomain.Character} character The character
     */
    pt.constructor = function (character) {

        this.character = character;
        this.characterRepository = new datadomain.CharacterRepository();

    };


<span id='domain-common-CharSprite-method-getPosition'>    /**
</span>     * Gets the CharPosition object.
     *
     * @return {datadomain.CharPosition}
     */
    pt.getPosition = function () {

        return this.character.position;

    };


<span id='domain-common-CharSprite-method-setPosition'>    /**
</span>     * Sets the CharPosition object.
     */
    pt.setPosition = function (position) {

        this.character.position = position;

        return this.save();

    };


<span id='domain-common-CharSprite-method-setFloorObjectId'>    /**
</span>     * Sets the character&#39;s floorObjectId
     *
     * @param {String} floorObjectId The floor object id
     */
    pt.setFloorObjectId = function (floorObjectId) {

        this.character.position.floorObjectId = floorObjectId;

        return this.save();

    };


<span id='domain-common-CharSprite-method-save'>    /**
</span>     * Synchronize current state of the character into the localStorage.
     */
    pt.save = function () {

        var that = this;

        return this.characterRepository.save(this.character).then(function () {

            return that;

        });

    };


<span id='domain-common-CharSprite-method-createDom'>    /**
</span>     * Creates the dom of the character.
     *
     * @return {jQuery}
     */
    pt.createDom = function () {

        return $(&#39;&lt;img /&gt;&#39;).addClass(this.cssClass).width(this.w).height(this.h).offset({
            // the center of bottom line of the image is the sprite&#39;s center.
            left: this.leftLimit(),
            top: this.y - this.h
        }).attr(&#39;src&#39;, this.downImage || this.image);

    };

<span id='domain-common-CharSprite-method-turn'>    /**
</span>     * Changes the direction the character currently heading for.
     *
     * @param {String} dir The direction (one of up, down, left or right)
     */
    pt.turn = function (dir) {
        var img;

        switch (dir) {
            case &#39;up&#39;: img = this.upImage; break;
            case &#39;down&#39;: img = this.downImage || this.image; break;
            case &#39;left&#39;: img = this.leftImage; break;
            case &#39;right&#39;: img = this.rightImage; break;
        }

        this.$dom.attr(&#39;src&#39;, img);
    };


    pt.getDirection = function (coordinate, to) {
        if (coordinate === &#39;x&#39;) {
            if (to &gt; this.x) {
                return &#39;right&#39;;
            } else {
                return &#39;left&#39;;
            }
        } else {
            if (to &gt; this.y) {
                return &#39;down&#39;;
            } else {
                return &#39;up&#39;;
            }
        }
    };

    pt.moveTo = function (coordinate, to, dur) {

        var dir = this.getDirection(coordinate, to);

        this.turn(dir);

        this.setDuration(dur);

        if (dir === &#39;up&#39; || dir === &#39;down&#39;) {
            this.moveToY(dir, to);
        } else {
            this.moveToX(dir, to);
        }

        return wait(dur);
    };


<span id='domain-common-CharSprite-method-rightLimit'>    /**
</span>     * Returns right limit x value.
     *
     * @return {Number} x value of the right limit of sprite
     */
    pt.rightLimit = function () {
        return this.x + this.w / 2;
    };

<span id='domain-common-CharSprite-method-leftLimit'>    /**
</span>     * Returns left limit x value.
     *
     * @return {Number} x value of the left limit of sprite
     */
    pt.leftLimit = function () {
        return this.x - this.w / 2;
    };

    pt.moveToY = function (dir, to) {
        var offset = this.getOffset();

        this.y = to;

        offset.top = to - this.h; // the center of bottom line is the sprite&#39;s coordinate.

        this.setOffset(offset);
    };

    pt.moveToX = function (dir, to) {
        var offset = this.getOffset();

        this.x = to;

        offset.left = to - this.w / 2; // the center of bottom line is the sprite&#39;s coordinate.

        this.setOffset(offset);
    };

    pt.speak = function (speech, opts) {

        opts = opts || {};

        var cancelDom = opts.cancelDom || this.$dom;
        var timeout = opts.timeout || defaultSpeechTimeout;

        var bubbleShown = this.$dom.speechBubble(speech, {

            width: $(window).width() * 0.8,
            height: 50,
            color: &#39;#328DE5&#39;,
            cssClass: this.name + &#39;-speech&#39;,
            partitionY: 2,
            partitionX: 10,
            duration: 600

        }).show();

        this.speechEndPromise = bubbleShown.then(function (sb) {

            return new Promise(function (resolve) {

                setTimeout(resolve, timeout);

                $(cancelDom).one(&#39;click touchstart&#39;, resolve);

            }).then(function () {

                $(cancelDom).off(&#39;click touchstart&#39;);

                return sb.hide();

            });
        });

        return bubbleShown;

    };

});
</pre>
</body>
</html>
